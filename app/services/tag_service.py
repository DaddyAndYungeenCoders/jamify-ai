from typing import List, Optional, Dict, Any, Tuple
import numpy as np

from app.utils.logger import logger


class TagService:
    # Définition des tags avec leurs plages de caractéristiques
    TAG_DEFINITIONS = {
        'Joyeux': {
            'valence': (0.7, 1.0),
            'danceability': (0.5, 0.9),
            'energy': (0.6, 0.9),
            'tempo': (100, 140)
        },
        'Triste': {
            'valence': (0.0, 0.3),
            'acousticness': (0.6, 1.0),
            'energy': (0.2, 0.5),
            'tempo': (50, 90)
        },
        'Énergique': {
            'energy': (0.8, 1.0),
            'danceability': (0.7, 1.0),
            'tempo': (120, 160),
            'loudness': (-10, 0)
        },
        'Relaxant': {
            'acousticness': (0.6, 1.0),
            'energy': (0.2, 0.5),
            'tempo': (60, 90),
            'valence': (0.4, 0.7)
        },
        'Romantique': {
            'valence': (0.5, 0.8),
            'tempo': (80, 110),
            'acousticness': (0.4, 0.7),
            'energy': (0.3, 0.6)
        },
        'Colérique': {
            'energy': (0.8, 1.0),
            'loudness': (-5, 0),
            'tempo': (120, 180),
            'danceability': (0.6, 0.9)
        },
        'Motivant': {
            'energy': (0.7, 1.0),
            'valence': (0.5, 0.8),
            'tempo': (100, 140),
            'danceability': (0.6, 0.9)
        },
        'Sombre': {
            'valence': (0.0, 0.3),
            'energy': (0.4, 0.7),
            'loudness': (-30, -10),
            'acousticness': (0.5, 1.0)
        },
        'Festif': {
            'danceability': (0.8, 1.0),
            'valence': (0.7, 1.0),
            'energy': (0.8, 1.0),
            'tempo': (120, 160)
        }
    }

    def __init__(self, tag_repository):
        """
        Initialise le générateur de tags

        :param tag_repository: Repository pour gérer les tags
        """
        self.tag_repository = tag_repository

    def _ensure_tags_exist(self):
        """
        Vérifie et crée les tags prédéfinis s'ils n'existent pas
        """
        for tag_name in self.TAG_DEFINITIONS.keys():
            existing_tag = self.tag_repository.get_tag_by_name(tag_name)
            if not existing_tag:
                self.tag_repository.add_tag(tag_name)

    def generate_tags(self, music_data: Dict[str, Any]) -> List[str]:
        """
        Génère les tags pour un morceau en fonction de ses caractéristiques

        :param music_data: Données musicales du morceau
        :return: Liste des tags correspondants
        """
        matching_tags = []

        for tag_name, tag_criteria in self.TAG_DEFINITIONS.items():
            if self._check_tag_match(music_data, tag_criteria):
                matching_tags.append(tag_name)

        return matching_tags

    def _check_tag_match(
            self,
            music_data: Dict[str, Any],
            tag_criteria: Dict[str, Tuple[float, float]]
    ) -> bool:
        """
        Vérifie si les caractéristiques d'un morceau correspondent aux critères d'un tag

        :param music_data: Données musicales
        :param tag_criteria: Critères du tag
        :return: True si le morceau correspond au tag, False sinon
        """
        matches = []

        for feature, (min_val, max_val) in tag_criteria.items():
            # Vérifier si la caractéristique existe dans les données musicales
            if feature in music_data and music_data[feature] is not None:
                # Vérifier si la valeur est dans la plage du tag
                matches.append(min_val <= music_data[feature] <= max_val)

        # Le tag correspond si au moins la moitié des critères sont satisfaits
        return len(matches) > 0 and np.mean(matches) >= 0.5

    def tag_music(self, music_data: Dict[str, Any], music_id):
        """
        Étiquette un morceau avec les tags correspondants

        :param music_data: Données musicales du morceau
        :param music_id: uuid of the music, generated by postgres
        """
        # Générer les tags
        tags = self.generate_tags(music_data)

        # Ajouter les tags au morceau
        logger.info(f"Ajout des tags {tags} au morceau {music_id}")
        for tag in tags:
            try:
                self.tag_repository.add_link_music_tag(music_id, str(tag))
            except Exception as e:
                logger.error(f"Erreur lors de l'ajout du tag {tag}: {e}")



